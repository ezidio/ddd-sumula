/**
 * This file was generated by the Jeddict
 */
package br.com.tdc.sumula.tradicional.model;

import br.com.tdc.sumula.tradicional.type.TempoDeJogo;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import javax.persistence.*;
import javax.validation.constraints.NotNull;

import static br.com.tdc.sumula.tradicional.type.TipoCartao.AMARELO;
import static br.com.tdc.sumula.tradicional.type.TipoCartao.VERMELHO;
import static org.apache.commons.lang3.Validate.isTrue;
import static org.apache.commons.lang3.Validate.notEmpty;
import static org.apache.commons.lang3.Validate.notNull;

/**
 * @author everton
 */
@Entity
public class Sumula {

    private static final int MAX_SUBSTITUICOES = 3;
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long numeroJogo;

    private String observacao;
    private String relatorioAssistente;

    @NotNull
    private LocalDateTime data;

    @NotNull
    private Integer rodada;

    @ManyToOne(targetEntity = Escalacao.class)
    private Escalacao casa;

    @ManyToOne(targetEntity = Escalacao.class)
    private Escalacao visitante;

    @Embedded
    private Arbitragem arbitragem;

    @ManyToOne(targetEntity = Campeonato.class)
    private Campeonato campeonato;

    @ManyToOne(targetEntity = Estadio.class)
    private Estadio estadio;

    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "id_sumula", nullable = false)
    private List<Gol> gols = new ArrayList<>();

    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "id_sumula", nullable = false)
    private List<Substituicao> substituicoes = new ArrayList<>();

    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "id_sumula", nullable = false)
    private List<Cartao> cartoes = new ArrayList<>();

    private Sumula(Builder builder) {
        numeroJogo = notNull(builder.numeroJogo, "Numero do jogo deve ser informado.");
        data = notNull(builder.data, "Data deve ser informada.");
        rodada = notNull(builder.rodada, "Rodada deve ser informada.");
        casa = notNull(builder.casa, "Escalação do time da casa deve ser informada.");
        visitante = notNull(builder.visitante, "Escalação do time visitante deve ser informada.");
        arbitragem = notNull(builder.arbitragem, "Arbitragem deve ser informada.");
        campeonato = notNull(builder.campeonato, "Campeonato deve ser informado.");
        estadio = notNull(builder.estadio, "Estadio deve ser informado.");
    }

    public static Builder newBuilder() {
        return new Builder();
    }

    public Optional<Relacionado> getRelacionado(Time time, int numero) {
        if (this.casa.getTime().equals(time)) {
            return this.casa.getRelacionadoPorNumero(numero);
        }

        if (this.visitante.getTime().equals(time)) {
            return this.visitante.getRelacionadoPorNumero(numero);
        }

        throw new IllegalArgumentException("Time " + time.getNome() + " não esta nesta partida.");
    }

    public boolean jogadorExpulso(TempoDeJogo tempo, Relacionado jogador) {
        return this.cartoes.stream()
                .filter(c -> c.getTipo().equals(VERMELHO))
                .filter(c -> c.getRelacionado().equals(jogador))
                .anyMatch(c -> c.getTempo().isBefore(tempo));
    }

    public boolean temAmarelo(TempoDeJogo tempo, Relacionado jogador) {
        return this.cartoes.stream()
                .filter(c -> c.getTipo().equals(AMARELO))
                .filter(c -> c.getRelacionado().equals(jogador))
                .anyMatch(c -> c.getTempo().isBefore(tempo));
    }

    public void addCartaoAmarelo(TempoDeJogo tempo, Relacionado relacionado, String motivo) {
        notEmpty(motivo, "Não é possível dar cartão amarelo sem informar o motivo.");
        notNull(tempo, "Não é possível dar cartão amarelo sem informar o tempo.");
        notNull(relacionado, "Não é possível dar cartão amarelo sem informar o jogador.");
        isTrue(!jogadorExpulso(tempo, relacionado), "Não é possível dar cartão amarelo á jogador já expulso.");

        this.cartoes.add(Cartao.newBuilder()
                .withTipo(temAmarelo(tempo, relacionado) ? VERMELHO : AMARELO)
                .withMotivo(motivo)
                .withRelacionado(relacionado)
                .withTempo(tempo)
                .build());
    }

    public void addCartaoVermelho(TempoDeJogo tempo, Relacionado relacionado, String motivo) {

        notEmpty(motivo, "Não é possível dar cartão vermelho sem informar o motivo.");
        notNull(tempo, "Não é possível dar cartão vermelho sem informar o tempo.");
        notNull(relacionado, "Não é possível dar cartão vermelho sem informar o jogador.");
        isTrue(!jogadorExpulso(tempo, relacionado), "Não é possível expulsar jogador já expulso.");
        this.cartoes.add(Cartao.newBuilder()
                .withTipo(VERMELHO)
                .withMotivo(motivo)
                .withRelacionado(relacionado)
                .withTempo(tempo)
                .build());
    }

    public boolean jogadorSubstituido(TempoDeJogo tempo, Relacionado jogador) {
        return this.substituicoes.stream()
                .filter(s -> s.getSaiu().equals(jogador))
                .anyMatch(s -> s.getTempo().isBefore(tempo));
    }

    public boolean jogadorEntrou(TempoDeJogo tempo, Relacionado jogador) {
        return this.substituicoes.stream()
                .filter(s -> s.getEntrou().equals(jogador))
                .anyMatch(s -> s.getTempo().isBefore(tempo));
    }

    public boolean estaEmCampo(TempoDeJogo tempo, Relacionado jogador) {
        return (jogador.isTitular() || jogadorEntrou(tempo, jogador)) &&
                !jogadorSubstituido(tempo, jogador) &&
                !jogadorExpulso(tempo, jogador);
    }

    public void addSubstituicao(TempoDeJogo tempo, Relacionado sair, Relacionado entrar) {
        notNull(tempo, "Não é possivel substituir sem informar o tempo.");
        notNull(sair, "Não é possivel substituir sem informar o jogador que irá sair.");
        notNull(entrar, "Não é possivel substituir sem informar o jogador que irá entrar.");

        isTrue(estaRelacionado(sair), "Jogador não pode sair na substituição pois não foi relacionado.");
        isTrue(estaRelacionado(entrar), "Jogador não pode entrar na substituição pois não foi relacionado.");
        isTrue(!jogadorExpulso(tempo, sair), "Jogador não pode sair na substituição pois foi expulso.");
        isTrue(!jogadorExpulso(tempo, entrar), "Jogador não pode entrar na substituição pois foi expulso.");
        isTrue(estaEmCampo(tempo, sair), "Jogador não pode sair na substituição pois não está em campo.");
        isTrue(!estaEmCampo(tempo, entrar), "Jogador não pode entrar na substituição pois já está em campo.");
        isTrue(!foiSubstituido(sair), "Jogador não pode sair na substituição pois já existe uma substuição para ele.");
        isTrue(sair.mesmoTimeDe(entrar), "Substituição deve ser realizada entre jogadores do mesmo time.");
        isTrue(numeroDeSubstituicoesPara(sair.getTime()) < MAX_SUBSTITUICOES, "Cada time pode substituir no máximo %d vezes.", MAX_SUBSTITUICOES);

        this.substituicoes.add(new Substituicao(tempo, sair, entrar));
    }

    private boolean foiSubstituido(Relacionado sair) {
        return this.substituicoes.stream().anyMatch(s -> s.getSaiu().equals(sair));
    }

    public long numeroDeSubstituicoesPara(Time time) {
        return this.substituicoes.stream().filter(s -> s.getTime().equals(time)).count();
    }

    public Long getNumeroJogo() {
        return numeroJogo;
    }

    public LocalDateTime getData() {
        return data;
    }

    public Integer getRodada() {
        return rodada;
    }

    public Campeonato getCampeonato() {
        return campeonato;
    }

    public Escalacao getEscalacaoCasa() {
        return casa;
    }

    public Escalacao getEscalacaoVisitante() {
        return visitante;
    }

    public Arbitragem getArbitragem() {
        return arbitragem;
    }

    public List<Substituicao> getSubstituicoes() {
        return Collections.unmodifiableList(this.substituicoes);
    }

    public List<Cartao> getCartoesAmarelo() {
        return this.cartoes.stream()
                .filter(Cartao::isAmarelo)
                .collect(Collectors.toList());
    }

    public List<Cartao> getCartoesVermelho() {
        return this.cartoes.stream()
                .filter(Cartao::isVermelho)
                .collect(Collectors.toList());
    }

    public void addGol(Gol gol) {
        notNull(gol, "Gol adicionado não pode ser nulo.");
        isTrue(timeEstaNoJogo(gol.getFavorecido()), "Gol deve ser favorecido a um time pertencente a partida.");
        isTrue(estaRelacionado(gol.getRelacionado()), "Jogador vinculado ao gol não esta relacionado por nenhum time.");
        isTrue(!jogadorExpulso(gol.getTempo(), gol.getRelacionado()), "Não pode ser anotado gol para jogador expulso.");
        isTrue(estaEmCampo(gol.getTempo(), gol.getRelacionado()), "Não pode ser anotado gol para jogador que não está em campo.");
        this.gols.add(gol);
    }

    private boolean estaRelacionado(Relacionado relacionado) {
        return casa.contem(relacionado) || visitante.contem(relacionado);
    }

    private boolean timeEstaNoJogo(Time time) {
        return time.equals(casa.getTime()) || time.equals(visitante.getTime());
    }

    public List<Gol> getGols() {
        return Collections.unmodifiableList(this.gols);
    }

    public long golsTimeCasa() {
        return gols.stream()
                .filter(gol -> gol.favorecidoA(casa.getTime()))
                .count();
    }

    public long golsTimeVisitante() {
        return gols.stream()
                .filter(gol -> gol.favorecidoA(visitante.getTime()))
                .count();
    }

    public Time getTimeCasa() {
        return getEscalacaoCasa().getTime();
    }

    public Time getTimeVisitante() {
        return getEscalacaoVisitante().getTime();
    }

    public Estadio getEstadio() {
        return estadio;
    }


    public static final class Builder {
        private Long numeroJogo;
        private LocalDateTime data;
        private Integer rodada;
        private Escalacao casa;
        private Escalacao visitante;
        private Arbitragem arbitragem;
        private Campeonato campeonato;
        private Estadio estadio;

        private Builder() {
        }

        public Builder withNumeroJogo(Long val) {
            numeroJogo = val;
            return this;
        }

        public Builder withEstadio(Estadio val) {
            estadio = val;
            return this;
        }

        public Builder withData(LocalDateTime val) {
            data = val;
            return this;
        }

        public Builder withRodada(Integer val) {
            rodada = val;
            return this;
        }

        public Builder withCasa(Escalacao val) {
            casa = val;
            return this;
        }

        public Builder withVisitante(Escalacao val) {
            visitante = val;
            return this;
        }

        public Builder withArbitragem(Arbitragem val) {
            arbitragem = val;
            return this;
        }

        public Sumula build() {
            return new Sumula(this);
        }

        public Builder withCampeonato(Campeonato val) {
            this.campeonato = val;
            return this;
        }
    }
}
